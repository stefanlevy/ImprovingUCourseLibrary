# Your First App

Your first Jinaga app will be in the public folder, so that anybody can access it without logging in.
You'll set up a connection to the back end, and then create view models to edit entities. You will
bind these to the view using KnockoutJS.

## Connect to the Back End

In the public folder, you created `myapp.js`. Open this again and create an instance of `Jinaga`. Sync
it with the distributor on the back end.

```JavaScript
var j = new Jinaga();
j.sync(new JinagaDistributor(distributorUrl));
var jko = new JinagaKnockout(j, ko);
```

The `distributorUrl` variable is defined in `config.js`, which is generated by the back end.

### Bind to synchronization status

Add some observables to your view model to keep track of synchronization status. The Jinaga Knockout
helper has a method to do that. Add this call to the MainViewModel constructor:

```JavaScript
jko.observeStatus(this);
```

Now bind those observables to the view. You will want to view the `status` and `error` properties:

```HTML
<div class="row">
  <div class="columns large-2"><span data-bind="text: status"></span></div>
  <div class="columns large-10"><span data-bind="text: error"></span></div>
</div>
```

With the back end running, refresh the page and see if the status message flashes. You can test the status
by stopping the back end. It should change to "Error". Start the back end again and the status will disappear.

## Root View Model

The main view model is for page-level properties. It doesn't contain domain information. Let's go down
one level and create a view model for the root of our domain. In this example, we will be talking about
a user group. First define a fact for the user group. Add this inside the MainViewModel constructor.

```JavaScript
var userGroup = {
  type: 'MyApp.UserGroup',
  identifier: 'papersdallas'
};
```

Then create a property of the main view model:

```JavaScript
this.userGroup = new UserGroupViewModel(userGroup, this);
```

### View model class

Below the MainViewModel function, you can define another function for the UserGroupViewModel constructor:

```JavaScript
function UserGroupViewModel(userGroup, vm) {
}
```

## Collections

The root view model will have a collection of children. This is a collection of child view models, each one wrapping a child fact. In this example, the child fact represents a user group meeting. Let's create the facts.

### Child facts

Define a function that creates a child fact.

```JavaScript
function newMeeting(userGroup) {
  return {
    type: 'MyApp.Meeting',
    createdAt: new Date(),
    userGroup: userGroup
  };
}
```

The `createdAt` field distinguishes one meeting from another. Without it, there can be only one meeting in a user group.

Call the method from the view model and data bind it to a button:

```JavaScript
this.addMeeting = function () {
  j.fact(newMeeting(userGroup));
};
```

```HTML
<div data-bind="with: userGroup">
  <div class="row">
    <div class="columns large-3">
      <button class="button" data-bind="click: addMeeting">Add Meeting</button>
    </div>
  </div>
</div>
```

Refresh the browser and click the button. You should see a message on the server that the user group and meeting facts were received:

```
jinaga.distributor.server [FCvcx] Received {
  "type":"MyApp.UserGroup",
  "identifier":"papersdallas"
}
jinaga.distributor.server [FCvcx] Received {
  "type":"MyApp.Meeting",
  "createdAt":"2016-10-31T01:33:48.889Z",
  "userGroup":{"id":1,"hash":2130125486}
}
```

Now let's work on displaying that meeting.

### Child view model

Create another file called `meeting.js`. Add the `<script>` reference to the HTML file. This will contain your meeting view model:

```JavaScript
function MeetingViewModel(meeting, vm) {
  this.title = meeting.createdAt;
}
```

We'll start with the created date as the title, just to see something on the screen. In a little bit, we'll replace that with the actual title.

Create a template function that matches meetings in a user group.

```JavaScript
function meetingsInUserGroup(userGroup) {
  return {
    type: 'MyApp.Meeting',
    userGroup: userGroup
  };
}
```

*More information on [template functions](https://github.com/michaellperry/jinaga/blob/master/TemplateFunctions.md).*

Add a `Collection` to the `UserGroupViewModel` for meetings matching this template. Call the `watch` function to start watching for these meetings:

```JavaScript
this.meetings = new jko.Collection(
  userGroup,
  [meetingsInUserGroup],
  MeetingViewModel,
  vm);
this.meetings.watch();
```

*More information on [Collection](https://github.com/michaellperry/jinaga.app.client/blob/master/Collection.md).*

This will create a `MeetingViewModel` for each meeting in the user group. The first parameter will be the meeting fact, but the second will be the main `vm`. Now you can bind the `items` of this collection and see the meeting you just added.

```JavaScript
<div class="row" data-bind="foreach: meetings.items">
  <div class="columns large-12">
    <span data-bind="text: title"></span>
  </div>
</div>
```

Refresh the browser and see if your meeting appears. If so, click the button and see if a new one is added. If the meetings do not appear, check the following:

- The `Sending` log message appears in the Node console for the `MyApp.Meeting`, indicating that you are watching the `Collection`.
- The error `Uncaught ReferenceError: Unable to process binding "foreach: function (){return meetings.items }"` does not appear in the browser console, indicating that your `foreach` binding is outside of the `with: userGroup` block.
- No other data binding errors appear in the browser console, indicating that you are not binding to `meetings.items`.

## Mutable properties

Now let's store and display the real meeting topic. This is a mutable property, meaning that the user can change it over time. The properties of a meeting that we've defined so far (`type`, `createdAt`, and `userGroup`) are immutable, meaning that the user cannot change them.

Define the title as a mutable property inside of the `MeetingViewModel` constructor. Replace the current definition of `this.title` with the following:

```JavaScript
this.title = new jko.Mutable('MyApp.Meeting.Title', meeting, '(new meeting)');
```

*More information on [Mutable](https://github.com/michaellperry/jinaga.app.client/blob/master/Mutable.md).*

The parameter is the default value of the property. This is the value that is displayed if the property hasn't yet been set.

### Binding to mutable properties

Back in the HTML, modify the binding to show not `title`, but `title.value`:

```JavaScript
<div class="row" data-bind="foreach: meetings.items">
  <div class="columns large-8">
    <span data-bind="text: title.value"></span>
  </div>
</div>
```

This will display the value of the mutable, or the default value if it hasn't been set. Refresh the browser, and you should see your existing meeting with the title *(new meeting)*.

### Watching mutable properties

When you watched the collection of meetings, you actually got back an object that allowed you to nest watches. Go back to the `UserGroupViewModel` and capture this object. Pass it to a function that we're about to write:

```JavaScript
var meetingsWatch = this.meetings.watch();
watchMeeting(meetingsWatch);
```

Now switch to `meeting.js` and write that function. Use the meetings watch to watch the `title` property of all children:

```JavaScript
function watchMeeting(meetingsWatch) {
    jko.watchMutable(meetingsWatch, 'title', 'MyApp.Meeting.Title');
}
```

*More information on [watchMutable](https://github.com/michaellperry/jinaga.app.client/blob/master/watchMutable.md).*

This starts watching for changes to the mutable property `title` using the type `MyApp.Meeting.Title`. Use the convention `Application.Entity.Property`.

### Capturing mutable properties

Now let's try changing that mutable property. We're going to open a modal. Create an observable in the `MainViewModel` for this modal:

```JavaScript
this.meetingModal = ko.observable();
```

We need to capture the current value of the property so that it doesn't update while the user has the modal open. Then, when the user clicks OK, save any changes in the captured value. Create a method in the `MeetingViewModel` to do that:

```JavaScript
this.edit = function() {
  vm.meetingModal({
    title: this.title.capture(),
    save: save
  });
  $('#meeting-modal').foundation('open');

  function save() {
    vm.meetingModal().title.save('MyApp.Meeting.Title');
    $('#meeting-modal').foundation('close');
  }
};
```

Create a modal dialog in HTML that binds to the `editModal` properties in the main view model. The below example is a Foundation modal.

```HTML
<div id="meeting-modal" class="reveal" data-reveal>
  <h1>Edit Meeting</h1>
  <div data-bind="with: meetingModal">
    <div class="row">
      <div class="col-md-4">
        <label for="meeting-title-edit">Title:</label>
      </div>
      <div class="col-md-8">
        <input type="text"
          name="meeting-title-edit" id="meeting-title-edit"
          data-bind="value: title.value">
      </div>
    </div>
    <div class="row">
      <button class="button" data-bind="click: save">OK</button>
      <button class="button" data-close>Cancel</button>
    </div>
  </div>
  <button class="close-button" data-close aria-label="Close modal" type="button">
    <span aria-hidden="true">&times;</span>
  </button>
</div>
```

The modal content data binds to the `meetingModal` property of the view model. The text input data binds `title.value`, and the OK button calls `save`. That will update the mutable with any changes that the user made to the value, using the fact type `MyApp.Meeting.Title`.

Create a button on the meeting row to call the edit function.

```HTML
  <div class="columns large-4">
    <button class="button" data-bind="click: edit">Edit</button>
  </div>
```

Now the modal captures the value of the mutable property and binds it to the modal. When the user edits the property and hits *save*, it records a new fact that represents the change.